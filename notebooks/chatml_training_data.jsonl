{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many orders were placed in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the total revenue generated from orders in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM(total_amount) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Who are the top 5 customers by the number of orders placed?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(o.id) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.id ORDER BY order_count DESC LIMIT 5"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which restaurant has the highest number of completed orders?"}, {"role": "assistant", "content": "SELECT r.name, COUNT(o.id) as completed_orders FROM restaurants r JOIN orders o ON r.id = o.restaurant_id WHERE o.status = 'completed' GROUP BY r.id ORDER BY completed_orders DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the average order amount for each restaurant?"}, {"role": "assistant", "content": "SELECT r.name, AVG(o.total_amount) as avg_order_amount FROM restaurants r JOIN orders o ON r.id = o.restaurant_id GROUP BY r.id"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many drivers are currently available?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM drivers WHERE available = 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the trend in the number of orders placed each day over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(order_date) as order_day, COUNT(*) as daily_orders FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY order_day ORDER BY order_day"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which customer has spent the most money on orders?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, SUM(o.total_amount) as total_spent FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.id ORDER BY total_spent DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the 3-day rolling average of orders placed per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_orders AS (SELECT date(order_date) as order_day, COUNT(*) as daily_orders FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY order_day) SELECT order_day, AVG(daily_orders) OVER (ORDER BY order_day ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg FROM daily_orders"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many orders have been cancelled in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM orders WHERE status = 'cancelled' AND order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which driver has delivered the most orders?"}, {"role": "assistant", "content": "SELECT d.first_name, d.last_name, COUNT(o.id) as delivered_orders FROM drivers d JOIN orders o ON d.id = o.driver_id GROUP BY d.id ORDER BY delivered_orders DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the average time taken for orders to be completed?"}, {"role": "assistant", "content": "SELECT AVG(julianday(order_date) - julianday((SELECT MIN(order_date) FROM orders))) as avg_completion_time FROM orders WHERE status = 'completed'"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many unique customers have placed orders in the past week?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-7 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which restaurant has the highest average order value in the most recent month?"}, {"role": "assistant", "content": "SELECT r.name, AVG(o.total_amount) as avg_order_value FROM restaurants r JOIN orders o ON r.id = o.restaurant_id WHERE o.order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month') GROUP BY r.id ORDER BY avg_order_value DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - available (BIGINT, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - driver_id (BIGINT)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the distribution of order statuses over the past 30 days?"}, {"role": "assistant", "content": "SELECT status, COUNT(*) as status_count FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY status"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: How many guests have made bookings in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT guest_id) FROM bookings WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the total revenue generated from bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM(total_price) FROM bookings WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: Who are the top 5 customers by the number of bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT g.first_name, g.last_name, COUNT(b.id) as booking_count FROM guests g JOIN bookings b ON g.id = b.guest_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days') GROUP BY g.id ORDER BY booking_count DESC LIMIT 5"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the average price per night for rooms that were booked in the most recent month?"}, {"role": "assistant", "content": "SELECT AVG(r.price_per_night) FROM rooms r JOIN bookings b ON r.id = b.room_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: Which room type has the highest number of bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT r.room_type, COUNT(b.id) as booking_count FROM rooms r JOIN bookings b ON r.id = b.room_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days') GROUP BY r.room_type ORDER BY booking_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the total payment amount for each payment method in the past 30 days?"}, {"role": "assistant", "content": "SELECT payment_method, SUM(payment_amount) as total_payment FROM payments WHERE payment_date >= date((SELECT MAX(payment_date) FROM payments), '-30 days') GROUP BY payment_method"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: How many bookings have been made for each room type in the past week?"}, {"role": "assistant", "content": "SELECT r.room_type, COUNT(b.id) as booking_count FROM rooms r JOIN bookings b ON r.id = b.room_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-7 days') GROUP BY r.room_type"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the average length of stay for bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT AVG(julianday(check_out_date) - julianday(check_in_date)) as avg_length_of_stay FROM bookings WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: Which guest has the highest total booking price in the past 30 days?"}, {"role": "assistant", "content": "SELECT g.first_name, g.last_name, SUM(b.total_price) as total_booking_price FROM guests g JOIN bookings b ON g.id = b.guest_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days') GROUP BY g.id ORDER BY total_booking_price DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: How many rooms are currently available?"}, {"role": "assistant", "content": "SELECT COUNT(id) FROM rooms WHERE is_available = 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the total revenue generated from each room type in the past 30 days?"}, {"role": "assistant", "content": "SELECT r.room_type, SUM(b.total_price) as total_revenue FROM rooms r JOIN bookings b ON r.id = b.room_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days') GROUP BY r.room_type"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: Which payment method has been used the most in the past 30 days?"}, {"role": "assistant", "content": "SELECT payment_method, COUNT(id) as payment_count FROM payments WHERE payment_date >= date((SELECT MAX(payment_date) FROM payments), '-30 days') GROUP BY payment_method ORDER BY payment_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: What is the average payment amount for each payment method in the past 30 days?"}, {"role": "assistant", "content": "SELECT payment_method, AVG(payment_amount) as avg_payment FROM payments WHERE payment_date >= date((SELECT MAX(payment_date) FROM payments), '-30 days') GROUP BY payment_method"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - total_price (DOUBLE, NOT NULL)\n\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: payments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - payment_amount (DOUBLE, NOT NULL)\n  - payment_date (TIMESTAMP, NOT NULL)\n  - payment_method (VARCHAR, NOT NULL)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_available (BIGINT)\n\nQuestion: How many bookings have been made by each guest in the past 30 days?"}, {"role": "assistant", "content": "SELECT g.first_name, g.last_name, COUNT(b.id) as booking_count FROM guests g JOIN bookings b ON g.id = b.guest_id WHERE b.check_in_date >= date((SELECT MAX(check_in_date) FROM bookings), '-30 days') GROUP BY g.id"}]}
