{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the trend of total sales over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(sale_date) as sale_date, SUM(total_amount) as total_sales FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-30 days') GROUP BY sale_date ORDER BY sale_date"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Which location has the highest number of vehicles?"}, {"role": "assistant", "content": "SELECT l.name, COUNT(v.id) AS vehicle_count FROM locations l JOIN vehicles v ON l.id = v.location_id GROUP BY l.name ORDER BY vehicle_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many orders were cancelled in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM orders WHERE status = 'cancelled' AND order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the total number of bookings made in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the average number of shipments per warehouse?"}, {"role": "assistant", "content": "SELECT AVG(shipment_count) AS avg_shipments_per_warehouse FROM ( SELECT COUNT(*) AS shipment_count FROM shipments GROUP BY warehouse_id ) AS subquery;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: How many customers have both a savings and a checking account?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) FROM accounts WHERE account_type IN ('savings', 'checking') GROUP BY customer_id HAVING COUNT(DISTINCT account_type) = 2;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: Which customer has the highest total loan amount?"}, {"role": "assistant", "content": "SELECT c.name, SUM(l.amount) AS total_loan_amount FROM customers c JOIN loans l ON c.id = l.customer_id GROUP BY c.name ORDER BY total_loan_amount DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Which customer has the most confirmed bookings?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(b.id) AS confirmed_bookings FROM customers c JOIN bookings b ON c.id = b.customer_id WHERE b.status = 'confirmed' GROUP BY c.id ORDER BY confirmed_bookings DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: What is the average cost of a rental?"}, {"role": "assistant", "content": "SELECT AVG(total_cost) AS avg_rental_cost FROM rentals;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the distribution of shipment statuses in the most recent month?"}, {"role": "assistant", "content": "SELECT status, COUNT(*) AS count FROM shipments WHERE shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-1 month') GROUP BY status;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Which customer has the longest gap between their first and last booking?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, MAX(b.booking_date) - MIN(b.booking_date) AS booking_gap FROM customers c JOIN bookings b ON c.id = b.customer_id GROUP BY c.id ORDER BY booking_gap DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Which destination has the most cancelled bookings in the recent month?"}, {"role": "assistant", "content": "SELECT d.name, COUNT(b.id) AS cancelled_bookings FROM bookings b JOIN destinations d ON b.destination_id = d.id WHERE b.status = 'cancelled' AND b.booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-1 month') GROUP BY d.id ORDER BY cancelled_bookings DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Which patient has the most medical records?"}, {"role": "assistant", "content": "SELECT p.first_name, p.last_name, COUNT(m.id) AS num_records FROM patients p JOIN medical_records m ON p.id = m.patient_id GROUP BY p.id ORDER BY num_records DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: Who are the top 5 carriers by the number of shipments they handled?"}, {"role": "assistant", "content": "SELECT c.name, COUNT(s.id) AS shipment_count FROM carriers c JOIN shipments s ON c.id = s.carrier_id GROUP BY c.name ORDER BY shipment_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What is the average length of stay for reservations in the past month?"}, {"role": "assistant", "content": "SELECT AVG(julianday(check_out_date) - julianday(check_in_date)) AS avg_length_of_stay FROM reservations WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Which specialty has the highest number of appointments?"}, {"role": "assistant", "content": "SELECT d.specialty, COUNT(a.id) AS num_appointments FROM doctors d JOIN appointments a ON d.id = a.doctor_id GROUP BY d.specialty ORDER BY num_appointments DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: Which hotel has the highest number of rooms?"}, {"role": "assistant", "content": "SELECT hotel_id, COUNT(*) AS room_count FROM rooms GROUP BY hotel_id ORDER BY room_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What is the average price per night for all rooms?"}, {"role": "assistant", "content": "SELECT AVG(price_per_night) FROM rooms;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: How many rentals have been made in the past week?"}, {"role": "assistant", "content": "SELECT COUNT(id) AS rental_count FROM rentals WHERE start_date >= date((SELECT MAX(start_date) FROM rentals), '-7 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which customer has the highest total spending on orders?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, SUM(o.total_amount) as total_spent FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.id ORDER BY total_spent DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which flight has the longest duration?"}, {"role": "assistant", "content": "SELECT flight_number, julianday(arrival_time) - julianday(departure_time) as duration FROM flights ORDER BY duration DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: How many rentals have been made in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(id) AS rental_count FROM rentals WHERE start_date >= date((SELECT MAX(start_date) FROM rentals), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Which doctor has the highest number of unique patients seen?"}, {"role": "assistant", "content": "SELECT d.first_name, d.last_name, COUNT(DISTINCT a.patient_id) AS num_unique_patients FROM doctors d JOIN appointments a ON d.id = a.doctor_id GROUP BY d.id ORDER BY num_unique_patients DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: How many unique diagnoses have been recorded in the medical records?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT diagnosis) FROM medical_records;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which flight has the highest number of bookings?"}, {"role": "assistant", "content": "SELECT f.flight_number, COUNT(b.id) as booking_count FROM flights f JOIN bookings b ON f.id = b.flight_id GROUP BY f.id ORDER BY booking_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: How many reservations were made in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM reservations WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which restaurant received the highest number of orders in the past week?"}, {"role": "assistant", "content": "SELECT r.name, COUNT(o.id) as order_count FROM restaurants r JOIN orders o ON r.id = o.restaurant_id WHERE o.order_date >= date((SELECT MAX(order_date) FROM orders), '-7 days') GROUP BY r.id ORDER BY order_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: Which warehouse has the highest number of shipments?"}, {"role": "assistant", "content": "SELECT w.name, COUNT(s.id) AS shipment_count FROM warehouses w JOIN shipments s ON w.id = s.warehouse_id GROUP BY w.name ORDER BY shipment_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the 3-day rolling average of shipments per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_shipments AS ( SELECT date(shipment_date) AS date, COUNT(*) AS count FROM shipments WHERE shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-30 days') GROUP BY date ), rolling_avg AS ( SELECT date, AVG(count) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_average FROM daily_shipments ) SELECT * FROM rolling_avg;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: How many patients have been registered?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM patients;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which customer placed the earliest order?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, MIN(o.order_date) as earliest_order FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.id ORDER BY earliest_order LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the average age of students?"}, {"role": "assistant", "content": "SELECT AVG(julianday('now') - julianday(date_of_birth)) / 365 as average_age FROM students;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: How many shipments were made in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM shipments WHERE shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: Who are the top 5 students by the number of enrollments?"}, {"role": "assistant", "content": "SELECT student_id, COUNT(*) as enrollment_count FROM enrollments GROUP BY student_id ORDER BY enrollment_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the 3-day rolling average of withdrawals per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_withdrawals AS (SELECT date(timestamp) AS date, SUM(amount) AS total_withdrawal FROM transactions WHERE transaction_type = 'withdrawal' AND timestamp >= date((SELECT MAX(timestamp) FROM transactions), '-30 days') GROUP BY date(timestamp)), rolling_avg AS (SELECT date, AVG(total_withdrawal) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_average FROM daily_withdrawals) SELECT * FROM rolling_avg;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the total balance across all checking accounts?"}, {"role": "assistant", "content": "SELECT SUM(balance) FROM accounts WHERE account_type = 'checking';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the total number of shipments for each destination in the past 30 days?"}, {"role": "assistant", "content": "SELECT destination, COUNT(*) AS shipment_count FROM shipments WHERE shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-30 days') GROUP BY destination;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the trend in the number of bookings over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(booking_date) as booking_day, COUNT(*) as daily_bookings FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days') GROUP BY booking_day ORDER BY booking_day;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: How many bookings were made in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: How many shipments are still pending delivery?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM shipments s JOIN deliveries d ON s.id = d.shipment_id WHERE d.delivery_status = 'pending';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: How many shipments have been delivered successfully in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM shipments s JOIN deliveries d ON s.id = d.shipment_id WHERE s.shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-1 month') AND d.delivery_status = 'delivered';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Which location has the highest average rental cost?"}, {"role": "assistant", "content": "SELECT l.name, AVG(r.total_cost) AS avg_rental_cost FROM locations l JOIN vehicles v ON l.id = v.location_id JOIN rentals r ON v.id = r.vehicle_id GROUP BY l.name ORDER BY avg_rental_cost DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Which product has the highest stock quantity?"}, {"role": "assistant", "content": "SELECT name, stock_quantity FROM products ORDER BY stock_quantity DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: How many guests have made more than one reservation?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT guest_id) FROM ( SELECT guest_id FROM reservations GROUP BY guest_id HAVING COUNT(*) > 1 );"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which origin airport has the most outgoing flights?"}, {"role": "assistant", "content": "SELECT origin, COUNT(*) as flight_count FROM flights GROUP BY origin ORDER BY flight_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: How many customers have at least one savings account?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) FROM accounts WHERE account_type = 'savings';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the average number of bookings per flight?"}, {"role": "assistant", "content": "SELECT AVG(booking_count) as avg_bookings_per_flight FROM (SELECT flight_id, COUNT(*) as booking_count FROM bookings GROUP BY flight_id);"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the 3-day rolling average of sales per day over the past 30 days?"}, {"role": "assistant", "content": "SELECT sale_date, AVG(total_sales) OVER (ORDER BY sale_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg FROM (SELECT date(sale_date) as sale_date, SUM(total_amount) as total_sales FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-30 days') GROUP BY sale_date) as daily_sales"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What is the total revenue generated from reservations in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM((julianday(check_out_date) - julianday(check_in_date)) * r.price_per_night) AS total_revenue FROM reservations res JOIN rooms r ON res.room_id = r.id WHERE res.check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the 3-day rolling average of orders per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_orders AS (SELECT date(order_date) as order_day, COUNT(*) as daily_orders FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY order_day) SELECT order_day, AVG(daily_orders) OVER (ORDER BY order_day ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg FROM daily_orders"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Which store has the highest number of sales?"}, {"role": "assistant", "content": "SELECT s.name, COUNT(*) as sales_count FROM sales sa JOIN stores s ON sa.store_id = s.id GROUP BY s.id ORDER BY sales_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: Who are the top 5 guests by the number of reservations made?"}, {"role": "assistant", "content": "SELECT guest_id, COUNT(*) AS reservation_count FROM reservations GROUP BY guest_id ORDER BY reservation_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: How many unique passengers have made bookings?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT passenger_id) FROM bookings;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Which restaurant has the highest average order amount?"}, {"role": "assistant", "content": "SELECT r.name, AVG(o.total_amount) as avg_order_amount FROM restaurants r JOIN orders o ON r.id = o.restaurant_id GROUP BY r.id ORDER BY avg_order_amount DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the 3-day rolling average of bookings per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_bookings AS ( SELECT date(booking_date) AS booking_day, COUNT(*) AS daily_count FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days') GROUP BY booking_day ), rolling_avg AS ( SELECT booking_day, AVG(daily_count) OVER (ORDER BY booking_day ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_average FROM daily_bookings ) SELECT * FROM rolling_avg;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the trend of total daily deposits over the past month?"}, {"role": "assistant", "content": "SELECT date(timestamp) AS date, SUM(amount) AS total_deposits FROM transactions WHERE transaction_type = 'deposit' AND timestamp >= date((SELECT MAX(timestamp) FROM transactions), '-1 month') GROUP BY date(timestamp) ORDER BY date(timestamp);"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: How many unique customers made a purchase in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the average number of appointments per patient in the past week?"}, {"role": "assistant", "content": "SELECT AVG(num_appointments) FROM (SELECT COUNT(*) AS num_appointments FROM appointments WHERE appointment_date >= date((SELECT MAX(appointment_date) FROM appointments), '-7 days') GROUP BY patient_id);"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: Which student has the highest grade?"}, {"role": "assistant", "content": "SELECT student_id, MAX(grade) as max_grade FROM enrollments GROUP BY student_id ORDER BY max_grade DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: How many flights have been recorded in the database?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM flights;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the average price of destinations booked in the past week?"}, {"role": "assistant", "content": "SELECT AVG(d.price) AS avg_price FROM bookings b JOIN destinations d ON b.destination_id = d.id WHERE b.booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-7 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Who are the top 5 customers by number of rentals?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(r.id) AS rental_count FROM customers c JOIN rentals r ON c.id = r.customer_id GROUP BY c.id ORDER BY rental_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the average grade of students in the most recent month?"}, {"role": "assistant", "content": "SELECT AVG(grade) FROM enrollments WHERE enrollment_date >= date((SELECT MAX(enrollment_date) FROM enrollments), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the distribution of enrollments by course title?"}, {"role": "assistant", "content": "SELECT c.title, COUNT(e.id) as enrollment_count FROM enrollments e JOIN courses c ON e.course_id = c.id GROUP BY c.title;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which passenger has booked the most seats on a single flight?"}, {"role": "assistant", "content": "SELECT p.first_name, p.last_name, COUNT(b.id) as seat_count FROM passengers p JOIN bookings b ON p.id = b.passenger_id GROUP BY p.id, b.flight_id ORDER BY seat_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Who are the top 5 customers by number of bookings?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(b.id) AS booking_count FROM customers c JOIN bookings b ON c.id = b.customer_id GROUP BY c.id ORDER BY booking_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Which vehicle make has the highest number of rentals?"}, {"role": "assistant", "content": "SELECT v.make, COUNT(r.id) AS rental_count FROM vehicles v JOIN rentals r ON v.id = r.vehicle_id GROUP BY v.make ORDER BY rental_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: Which course has the highest average grade?"}, {"role": "assistant", "content": "SELECT course_id, AVG(grade) as average_grade FROM enrollments GROUP BY course_id ORDER BY average_grade DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the 3-day rolling average of enrollments per day over the past 30 days?"}, {"role": "assistant", "content": "SELECT date, AVG(enrollment_count) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg FROM (SELECT date(enrollment_date) as date, COUNT(*) as enrollment_count FROM enrollments WHERE enrollment_date >= date((SELECT MAX(enrollment_date) FROM enrollments), '-30 days') GROUP BY date) as daily_enrollments;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: How many courses does each instructor teach?"}, {"role": "assistant", "content": "SELECT instructor_id, COUNT(*) as course_count FROM courses GROUP BY instructor_id;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: Which customer has the most recent transaction?"}, {"role": "assistant", "content": "SELECT c.name FROM customers c JOIN accounts a ON c.id = a.customer_id JOIN transactions t ON a.id = t.account_id WHERE t.timestamp = (SELECT MAX(timestamp) FROM transactions);"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: How many appointments were scheduled but not completed?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM appointments WHERE status = 'Scheduled';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the distribution of order statuses in the past week?"}, {"role": "assistant", "content": "SELECT status, COUNT(*) as status_count FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-7 days') GROUP BY status"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: Which room type has the highest average price per night?"}, {"role": "assistant", "content": "SELECT room_type, AVG(price_per_night) AS avg_price FROM rooms GROUP BY room_type ORDER BY avg_price DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many orders does each restaurant have on average per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_restaurant_orders AS (SELECT r.id as restaurant_id, date(o.order_date) as order_day, COUNT(*) as daily_orders FROM restaurants r JOIN orders o ON r.id = o.restaurant_id WHERE o.order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY r.id, order_day) SELECT restaurant_id, AVG(daily_orders) as avg_daily_orders FROM daily_restaurant_orders GROUP BY restaurant_id"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Which city has the most stores?"}, {"role": "assistant", "content": "SELECT city, COUNT(*) as store_count FROM stores GROUP BY city ORDER BY store_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the average interest rate of approved loans?"}, {"role": "assistant", "content": "SELECT AVG(interest_rate) FROM loans WHERE status = 'approved';"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Which store has the highest average sale amount?"}, {"role": "assistant", "content": "SELECT s.name, AVG(sa.total_amount) as avg_sale_amount FROM sales sa JOIN stores s ON sa.store_id = s.id GROUP BY s.id ORDER BY avg_sale_amount DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: How many itineraries have been created for bookings in the past week?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM itineraries i JOIN bookings b ON i.booking_id = b.id WHERE b.booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-7 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: Which carrier has the highest number of deliveries in the past week?"}, {"role": "assistant", "content": "SELECT c.name, COUNT(d.id) AS delivery_count FROM carriers c JOIN shipments s ON c.id = s.carrier_id JOIN deliveries d ON s.id = d.shipment_id WHERE d.delivery_date >= date((SELECT MAX(delivery_date) FROM deliveries), '-7 days') GROUP BY c.name ORDER BY delivery_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the total number of deliveries in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM deliveries WHERE delivery_date >= date((SELECT MAX(delivery_date) FROM deliveries), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the average number of enrollments per course?"}, {"role": "assistant", "content": "SELECT AVG(enrollment_count) FROM (SELECT course_id, COUNT(*) as enrollment_count FROM enrollments GROUP BY course_id) as course_enrollments;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which crew member has been assigned to the most flights?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(fca.id) as assignment_count FROM crew_members c JOIN flight_crew_assignments fca ON c.id = fca.crew_member_id GROUP BY c.id ORDER BY assignment_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the trend in the number of appointments over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(appointment_date) AS date, COUNT(id) AS num_appointments FROM appointments WHERE appointment_date >= date((SELECT MAX(appointment_date) FROM appointments), '-30 days') GROUP BY date ORDER BY date;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: What is the trend in the number of rentals over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(start_date) AS rental_day, COUNT(*) AS daily_rentals FROM rentals WHERE start_date >= date((SELECT MAX(start_date) FROM rentals), '-30 days') GROUP BY rental_day ORDER BY rental_day;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: Which hotel has the highest number of reservations in the past week?"}, {"role": "assistant", "content": "SELECT h.id, COUNT(*) AS reservation_count FROM reservations res JOIN rooms r ON res.room_id = r.id JOIN hotels h ON r.hotel_id = h.id WHERE res.check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-7 days') GROUP BY h.id ORDER BY reservation_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: How many unique customers have made bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) AS unique_customers FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the average order amount for completed orders?"}, {"role": "assistant", "content": "SELECT AVG(total_amount) FROM orders WHERE status = 'completed'"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Which doctor has the most completed appointments in the most recent month?"}, {"role": "assistant", "content": "SELECT d.first_name, d.last_name, COUNT(a.id) AS num_completed FROM doctors d JOIN appointments a ON d.id = a.doctor_id WHERE a.status = 'Completed' AND a.appointment_date >= date((SELECT MAX(appointment_date) FROM appointments), '-1 month') GROUP BY d.id ORDER BY num_completed DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: How many students are enrolled in courses?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT student_id) FROM enrollments;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: How many enrollments were there in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM enrollments WHERE enrollment_date >= date((SELECT MAX(enrollment_date) FROM enrollments), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the difference in days between the earliest and latest order dates?"}, {"role": "assistant", "content": "SELECT julianday(MAX(order_date)) - julianday(MIN(order_date)) as days_diff FROM orders"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: Which instructor has the most courses?"}, {"role": "assistant", "content": "SELECT instructor_id, COUNT(*) as course_count FROM courses GROUP BY instructor_id ORDER BY course_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the average age of patients?"}, {"role": "assistant", "content": "SELECT AVG(julianday('now') - julianday(date_of_birth)) / 365 AS avg_age FROM patients;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the average age of passengers who have made bookings?"}, {"role": "assistant", "content": "SELECT AVG(julianday('now') - julianday(p.date_of_birth)) / 365.25 as average_age FROM passengers p JOIN bookings b ON p.id = b.passenger_id;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many orders were placed in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the average duration of activities in the itineraries?"}, {"role": "assistant", "content": "SELECT AVG(julianday(end_time) - julianday(start_time)) AS avg_duration FROM itineraries;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the average number of sales per day over the past 30 days?"}, {"role": "assistant", "content": "SELECT AVG(sales_count) as avg_sales_per_day FROM (SELECT date(sale_date) as sale_date, COUNT(*) as sales_count FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-30 days') GROUP BY sale_date) as daily_sales"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Which customer has made the most purchases?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(*) as purchase_count FROM sales s JOIN customers c ON s.customer_id = c.id GROUP BY c.id ORDER BY purchase_count DESC LIMIT 1"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What is the trend of enrollments over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(enrollment_date) as date, COUNT(*) as enrollment_count FROM enrollments WHERE enrollment_date >= date((SELECT MAX(enrollment_date) FROM enrollments), '-30 days') GROUP BY date ORDER BY date;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Which destination has the highest number of bookings in the recent month?"}, {"role": "assistant", "content": "SELECT d.name, COUNT(b.id) AS booking_count FROM bookings b JOIN destinations d ON b.destination_id = d.id WHERE b.booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-1 month') GROUP BY d.id ORDER BY booking_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What is the total number of rooms across all hotels?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM rooms;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: Who are the top 5 customers by total sales amount?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, SUM(s.total_amount) as total_sales FROM sales s JOIN customers c ON s.customer_id = c.id GROUP BY c.id ORDER BY total_sales DESC LIMIT 5"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: How many vehicles are currently available at each location?"}, {"role": "assistant", "content": "SELECT l.name, COUNT(v.id) AS vehicle_count FROM locations l JOIN vehicles v ON l.id = v.location_id GROUP BY l.name;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Which patient has the longest gap between their first and last medical record?"}, {"role": "assistant", "content": "SELECT p.first_name, p.last_name, MAX(julianday(m.record_date)) - MIN(julianday(m.record_date)) AS gap_days FROM patients p JOIN medical_records m ON p.id = m.patient_id GROUP BY p.id ORDER BY gap_days DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the average number of days between shipment and delivery dates over the past 30 days?"}, {"role": "assistant", "content": "SELECT AVG(julianday(d.delivery_date) - julianday(s.shipment_date)) AS avg_days FROM shipments s JOIN deliveries d ON s.id = d.shipment_id WHERE s.shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: How many unique customers have placed orders in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(DISTINCT customer_id) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the total amount of deposits made in the past week?"}, {"role": "assistant", "content": "SELECT SUM(amount) FROM transactions WHERE transaction_type = 'deposit' AND timestamp >= date((SELECT MAX(timestamp) FROM transactions), '-7 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: How many transactions were made on the most recent day?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM transactions WHERE date(timestamp) = date((SELECT MAX(timestamp) FROM transactions));"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: What is the total revenue generated from rentals in the most recent month?"}, {"role": "assistant", "content": "SELECT SUM(total_cost) AS total_revenue FROM rentals WHERE start_date >= date((SELECT MAX(start_date) FROM rentals), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: Which destination has the highest average price among those with more than 10 bookings?"}, {"role": "assistant", "content": "SELECT d.name, AVG(d.price) AS avg_price FROM bookings b JOIN destinations d ON b.destination_id = d.id GROUP BY d.id HAVING COUNT(b.id) > 10 ORDER BY avg_price DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the average balance of savings accounts for customers who have taken out a loan?"}, {"role": "assistant", "content": "SELECT AVG(a.balance) FROM accounts a JOIN customers c ON a.customer_id = c.id WHERE a.account_type = 'savings' AND c.id IN (SELECT customer_id FROM loans);"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the most common role among crew members?"}, {"role": "assistant", "content": "SELECT role, COUNT(*) as role_count FROM crew_members GROUP BY role ORDER BY role_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: How many sales were made in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-1 month')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: Which account type has the highest average balance?"}, {"role": "assistant", "content": "SELECT account_type, AVG(balance) AS avg_balance FROM accounts GROUP BY account_type ORDER BY avg_balance DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: How many students were born in the last 20 years?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM students WHERE date_of_birth >= date('now', '-20 years');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: How many hotels are there in the database?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM hotels;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: Who are the top 5 customers by the number of orders in the recent month?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, COUNT(o.id) as order_count FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.order_date >= date((SELECT MAX(order_date) FROM orders), '-1 month') GROUP BY c.id ORDER BY order_count DESC LIMIT 5"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: Which city has the highest number of hotels?"}, {"role": "assistant", "content": "SELECT city, COUNT(*) AS hotel_count FROM hotels GROUP BY city ORDER BY hotel_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What is the 3-day rolling average of reservations per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_reservations AS ( SELECT date(check_in_date) AS check_in_date, COUNT(*) AS reservation_count FROM reservations WHERE check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-30 days') GROUP BY check_in_date ), rolling_avg AS ( SELECT check_in_date, AVG(reservation_count) OVER (ORDER BY check_in_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_average FROM daily_reservations ) SELECT * FROM rolling_avg;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: What is the 3-day rolling average of rentals per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_rentals AS (SELECT date(start_date) AS rental_day, COUNT(*) AS daily_count FROM rentals WHERE start_date >= date((SELECT MAX(start_date) FROM rentals), '-30 days') GROUP BY rental_day) SELECT rental_day, AVG(daily_count) OVER (ORDER BY rental_day ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_avg FROM daily_rentals;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Which nationality has the most passengers who have made bookings?"}, {"role": "assistant", "content": "SELECT p.nationality, COUNT(b.id) as booking_count FROM passengers p JOIN bookings b ON p.id = b.passenger_id GROUP BY p.nationality ORDER BY booking_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: Which carrier has the fastest average delivery time over the past 30 days?"}, {"role": "assistant", "content": "SELECT c.name, AVG(julianday(d.delivery_date) - julianday(s.shipment_date)) AS avg_delivery_time FROM carriers c JOIN shipments s ON c.id = s.carrier_id JOIN deliveries d ON s.id = d.shipment_id WHERE s.shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-30 days') GROUP BY c.name ORDER BY avg_delivery_time ASC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the total number of medical records created in the most recent month?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM medical_records WHERE record_date >= date((SELECT MAX(record_date) FROM medical_records), '-1 month');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: What is the 3-day rolling average of bookings per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_bookings AS (SELECT date(booking_date) as booking_day, COUNT(*) as daily_bookings FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days') GROUP BY booking_day) SELECT booking_day, AVG(daily_bookings) OVER (ORDER BY booking_day ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as rolling_avg FROM daily_bookings;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the distribution of patients by gender?"}, {"role": "assistant", "content": "SELECT gender, COUNT(*) AS count FROM patients GROUP BY gender;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the average sale amount per customer?"}, {"role": "assistant", "content": "SELECT AVG(total_amount) as avg_sale_amount FROM sales"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the total amount spent by customers in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM(total_amount) FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the distribution of booking statuses over the past 30 days?"}, {"role": "assistant", "content": "SELECT status, COUNT(*) AS status_count FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days') GROUP BY status;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: How many rentals were made in each city?"}, {"role": "assistant", "content": "SELECT l.city, COUNT(r.id) AS rental_count FROM locations l JOIN vehicles v ON l.id = v.location_id JOIN rentals r ON v.id = r.vehicle_id GROUP BY l.city;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: Who are the top 5 doctors by the number of appointments scheduled?"}, {"role": "assistant", "content": "SELECT d.first_name, d.last_name, COUNT(a.id) AS num_appointments FROM doctors d JOIN appointments a ON d.id = a.doctor_id GROUP BY d.id ORDER BY num_appointments DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: What is the total amount of loans that are still active?"}, {"role": "assistant", "content": "SELECT SUM(amount) FROM loans WHERE status NOT IN ('paid', 'rejected');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the trend in the number of bookings over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(booking_date) AS booking_day, COUNT(*) AS daily_bookings FROM bookings WHERE booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days') GROUP BY booking_day ORDER BY booking_day;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: What is the average duration of a rental?"}, {"role": "assistant", "content": "SELECT AVG(julianday(end_date) - julianday(start_date)) AS avg_duration FROM rentals;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the average price of products currently in stock?"}, {"role": "assistant", "content": "SELECT AVG(price) as avg_price FROM products"}]}
