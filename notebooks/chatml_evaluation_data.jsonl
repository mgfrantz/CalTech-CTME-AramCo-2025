{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: accounts\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - account_number (VARCHAR, NOT NULL)\n  - balance (DOUBLE, NOT NULL)\n  - account_type (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - email (VARCHAR, NOT NULL)\n  - phone (VARCHAR)\n\nTable: loans\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - loan_number (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - interest_rate (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: transactions\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - transaction_type (VARCHAR, NOT NULL)\n  - amount (DOUBLE, NOT NULL)\n  - timestamp (TIMESTAMP, NOT NULL)\n  - account_id (BIGINT, NOT NULL)\n\nQuestion: Who are the top 5 customers by the number of transactions in the most recent month?"}, {"role": "assistant", "content": "SELECT c.name, COUNT(t.id) AS transaction_count FROM customers c JOIN accounts a ON c.id = a.customer_id JOIN transactions t ON a.id = t.account_id WHERE t.timestamp >= date((SELECT MAX(timestamp) FROM transactions), '-1 month') GROUP BY c.name ORDER BY transaction_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: appointments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - doctor_id (BIGINT, NOT NULL)\n  - appointment_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: doctors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - specialty (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR)\n\nTable: medical_records\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - patient_id (BIGINT, NOT NULL)\n  - record_date (TIMESTAMP, NOT NULL)\n  - diagnosis (VARCHAR)\n  - treatment (VARCHAR)\n  - notes (VARCHAR)\n\nTable: patients\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - gender (VARCHAR, NOT NULL)\n  - address (VARCHAR)\n  - phone_number (VARCHAR)\n\nQuestion: What is the 3-day rolling average of appointments per day over the past 30 days?"}, {"role": "assistant", "content": "WITH daily_counts AS (SELECT date(appointment_date) AS date, COUNT(id) AS num_appointments FROM appointments WHERE appointment_date >= date((SELECT MAX(appointment_date) FROM appointments), '-30 days') GROUP BY date), rolling_averages AS (SELECT date, AVG(num_appointments) OVER (ORDER BY date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS rolling_avg FROM daily_counts) SELECT * FROM rolling_averages;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Which customer has spent the most money on rentals?"}, {"role": "assistant", "content": "SELECT c.first_name, c.last_name, SUM(r.total_cost) AS total_spent FROM customers c JOIN rentals r ON c.id = r.customer_id GROUP BY c.id ORDER BY total_spent DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - passenger_id (BIGINT, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - seat_number (VARCHAR, NOT NULL)\n\nTable: crew_members\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - role (VARCHAR, NOT NULL)\n\nTable: flight_crew_assignments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_id (BIGINT, NOT NULL)\n  - crew_member_id (BIGINT, NOT NULL)\n\nTable: flights\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - flight_number (VARCHAR, NOT NULL)\n  - departure_time (TIMESTAMP, NOT NULL)\n  - arrival_time (TIMESTAMP, NOT NULL)\n  - origin (VARCHAR, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n\nTable: passengers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n  - nationality (VARCHAR, NOT NULL)\n\nQuestion: Who are the top 5 passengers by the number of bookings?"}, {"role": "assistant", "content": "SELECT p.first_name, p.last_name, COUNT(b.id) as booking_count FROM passengers p JOIN bookings b ON p.id = b.passenger_id GROUP BY p.id ORDER BY booking_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: Which instructor has the most enrollments?"}, {"role": "assistant", "content": "SELECT i.id, COUNT(e.id) as enrollment_count FROM enrollments e JOIN courses c ON e.course_id = c.id JOIN instructors i ON c.instructor_id = i.id GROUP BY i.id ORDER BY enrollment_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the total revenue generated in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM(total_amount) FROM sales WHERE sale_date >= date((SELECT MAX(sale_date) FROM sales), '-30 days')"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: bookings\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - destination_id (BIGINT, NOT NULL)\n  - booking_date (TIMESTAMP, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: destinations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n\nTable: itineraries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - booking_id (BIGINT, NOT NULL)\n  - activity (VARCHAR, NOT NULL)\n  - start_time (TIMESTAMP, NOT NULL)\n  - end_time (TIMESTAMP, NOT NULL)\n\nQuestion: What is the total revenue generated from bookings in the past 30 days?"}, {"role": "assistant", "content": "SELECT SUM(d.price) AS total_revenue FROM bookings b JOIN destinations d ON b.destination_id = d.id WHERE b.booking_date >= date((SELECT MAX(booking_date) FROM bookings), '-30 days');"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: What is the trend in the number of shipments over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(shipment_date) AS date, COUNT(*) AS shipment_count FROM shipments WHERE shipment_date >= date((SELECT MAX(shipment_date) FROM shipments), '-30 days') GROUP BY date ORDER BY date;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR)\n\nTable: products\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - price (DOUBLE, NOT NULL)\n  - stock_quantity (BIGINT, NOT NULL)\n\nTable: sales\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - sale_date (TIMESTAMP, NOT NULL)\n  - quantity (BIGINT, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - store_id (BIGINT, NOT NULL)\n  - product_id (BIGINT, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n\nTable: stores\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nQuestion: What is the total revenue generated by each product in the past 30 days?"}, {"role": "assistant", "content": "SELECT p.name, SUM(s.total_amount) as total_revenue FROM sales s JOIN products p ON s.product_id = p.id WHERE s.sale_date >= date((SELECT MAX(sale_date) FROM sales), '-30 days') GROUP BY p.id ORDER BY total_revenue DESC"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: drivers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n  - license_number (VARCHAR, NOT NULL)\n\nTable: orders\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - restaurant_id (BIGINT, NOT NULL)\n  - order_date (TIMESTAMP, NOT NULL)\n  - total_amount (DOUBLE, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: restaurants\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nQuestion: What is the trend in the number of orders per day over the past 30 days?"}, {"role": "assistant", "content": "SELECT date(order_date) as order_day, COUNT(*) as daily_orders FROM orders WHERE order_date >= date((SELECT MAX(order_date) FROM orders), '-30 days') GROUP BY order_day ORDER BY order_day"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: carriers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - contact_info (VARCHAR, NOT NULL)\n\nTable: deliveries\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - shipment_id (BIGINT, NOT NULL)\n  - delivery_date (TIMESTAMP, NOT NULL)\n  - delivery_status (VARCHAR, NOT NULL)\n\nTable: shipments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - warehouse_id (BIGINT, NOT NULL)\n  - carrier_id (BIGINT, NOT NULL)\n  - shipment_date (TIMESTAMP, NOT NULL)\n  - destination (VARCHAR, NOT NULL)\n  - status (VARCHAR, NOT NULL)\n\nTable: warehouses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - location (VARCHAR, NOT NULL)\n\nQuestion: Which warehouse has the most deliveries in the past 30 days?"}, {"role": "assistant", "content": "SELECT w.name, COUNT(d.id) AS delivery_count FROM warehouses w JOIN shipments s ON w.id = s.warehouse_id JOIN deliveries d ON s.id = d.shipment_id WHERE d.delivery_date >= date((SELECT MAX(delivery_date) FROM deliveries), '-30 days') GROUP BY w.name ORDER BY delivery_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: customers\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: locations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - zip_code (VARCHAR, NOT NULL)\n\nTable: rentals\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - customer_id (BIGINT, NOT NULL)\n  - vehicle_id (BIGINT, NOT NULL)\n  - start_date (TIMESTAMP, NOT NULL)\n  - end_date (TIMESTAMP, NOT NULL)\n  - total_cost (DOUBLE, NOT NULL)\n\nTable: vehicles\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - make (VARCHAR, NOT NULL)\n  - model (VARCHAR, NOT NULL)\n  - year (BIGINT, NOT NULL)\n  - color (VARCHAR, NOT NULL)\n  - license_plate (VARCHAR, NOT NULL)\n  - location_id (BIGINT, NOT NULL)\n\nQuestion: Which vehicle has been rented the most times?"}, {"role": "assistant", "content": "SELECT v.make, v.model, COUNT(r.id) AS rental_count FROM vehicles v JOIN rentals r ON v.id = r.vehicle_id GROUP BY v.id ORDER BY rental_count DESC LIMIT 1;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: courses\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - title (VARCHAR, NOT NULL)\n  - description (VARCHAR)\n  - instructor_id (BIGINT, NOT NULL)\n\nTable: enrollments\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - student_id (BIGINT, NOT NULL)\n  - course_id (BIGINT, NOT NULL)\n  - enrollment_date (TIMESTAMP, NOT NULL)\n  - grade (DOUBLE)\n\nTable: instructors\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - expertise (VARCHAR, NOT NULL)\n\nTable: students\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - date_of_birth (TIMESTAMP, NOT NULL)\n\nQuestion: What are the top 5 courses by the number of enrollments?"}, {"role": "assistant", "content": "SELECT course_id, COUNT(*) as enrollment_count FROM enrollments GROUP BY course_id ORDER BY enrollment_count DESC LIMIT 5;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: What percentage of rooms are currently booked?"}, {"role": "assistant", "content": "SELECT CAST(SUM(CASE WHEN is_booked THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS booking_percentage FROM rooms;"}]}
{"conversations": [{"role": "system", "content": "You are an expert SQL developer specializing in SQLite. Generate accurate SQL queries that follow these requirements:\n\nSQLITE REQUIREMENTS:\n1. Use only standard SQLite-compatible SQL syntax\n2. Avoid PostgreSQL-specific functions like INTERVAL - use date arithmetic instead\n3. Use SQLite date functions: date(), datetime(), julianday() for date calculations\n4. For \"recent month\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-1 month')\n5. For \"past 30 days\" use: WHERE date_column >= date((SELECT MAX(date_column) FROM table_name), '-30 days')\n6. For rolling averages, use window functions or subqueries\n7. Use MAX(appropriate_date_column) to find the most recent date\n8. Use proper SQLite column types: INTEGER, TEXT, REAL, BLOB\n9. Handle foreign key relationships correctly with proper JOIN syntax\n\nQUERY STANDARDS:\n- Write clear, efficient queries\n- Use appropriate aggregation functions (COUNT, SUM, AVG, MAX, MIN)\n- Include proper GROUP BY and ORDER BY clauses when needed\n- Use table aliases for readability in complex queries"}, {"role": "user", "content": "Database Schema:\nTable: guests\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - first_name (VARCHAR, NOT NULL)\n  - last_name (VARCHAR, NOT NULL)\n  - email (VARCHAR, NOT NULL)\n  - phone_number (VARCHAR, NOT NULL)\n\nTable: hotels\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - name (VARCHAR, NOT NULL)\n  - address (VARCHAR, NOT NULL)\n  - city (VARCHAR, NOT NULL)\n  - state (VARCHAR, NOT NULL)\n  - country (VARCHAR, NOT NULL)\n\nTable: reservations\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - guest_id (BIGINT, NOT NULL)\n  - room_id (BIGINT, NOT NULL)\n  - check_in_date (TIMESTAMP, NOT NULL)\n  - check_out_date (TIMESTAMP, NOT NULL)\n  - is_cancelled (BIGINT)\n\nTable: rooms\n  - id (BIGINT, PRIMARY KEY, NOT NULL)\n  - hotel_id (BIGINT, NOT NULL)\n  - room_number (VARCHAR, NOT NULL)\n  - room_type (VARCHAR, NOT NULL)\n  - price_per_night (DOUBLE, NOT NULL)\n  - is_booked (BIGINT)\n\nQuestion: How many reservations were cancelled in the past 30 days?"}, {"role": "assistant", "content": "SELECT COUNT(*) FROM reservations WHERE is_cancelled = 1 AND check_in_date >= date((SELECT MAX(check_in_date) FROM reservations), '-30 days');"}]}
